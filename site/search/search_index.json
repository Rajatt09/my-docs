{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to My Docs","text":"<p>This is the personal documentation site of Rajat Bhati.</p>"},{"location":"#about-me","title":"About Me","text":"<ul> <li>GitHub: https://github.com/Rajatt09</li> <li>LinkedIn: https://www.linkedin.com/in/rajatbhati</li> <li>Email: rajatbhati9559@gmail.com</li> </ul>"},{"location":"#documentation","title":"Documentation","text":"<p>This site contains documentation for various tools and technologies that I use. It includes snippets and information that I refer to occasionally.</p>"},{"location":"mkdocs/information/mkdocs-info/","title":"MkDocs Setup Information","text":""},{"location":"mkdocs/information/mkdocs-info/#introduction","title":"Introduction","text":"<p>MkDocs is a static site generator that's geared towards project documentation. It is written in Python and is easy to configure and deploy.</p>"},{"location":"mkdocs/information/mkdocs-info/#installation","title":"Installation","text":"<p>To install MkDocs, use the following command:</p> <pre><code>pip install mkdocs\n</code></pre>"},{"location":"mkdocs/information/mkdocs-info/#creating-a-new-project","title":"Creating a New Project","text":"<p>To create a new MkDocs project, run:</p> <pre><code>mkdocs new my-project\ncd my-project\n</code></pre>"},{"location":"mkdocs/information/mkdocs-info/#running-the-project","title":"Running the Project","text":"<p>To start the live-reloading docs server, use:</p> <pre><code>mkdocs serve\n</code></pre> <p>You can then view the documentation at <code>http://127.0.0.1:8000/</code>.</p>"},{"location":"mkdocs/information/mkdocs-info/#building-the-documentation","title":"Building the Documentation","text":"<p>To build the documentation, run:</p> <pre><code>mkdocs build\n</code></pre> <p>This will create a <code>site</code> directory with your static site.</p>"},{"location":"mkdocs/information/mkdocs-info/#configuration","title":"Configuration","text":"<p>The configuration file <code>mkdocs.yml</code> is where you configure your MkDocs project. Here is an example configuration:</p> <pre><code># filepath: myDocs/my-project/mkdocs.yml\nsite_name: My Documentation Project\ntheme:\n  name: material\n  custom_dir: docs/overrides\n\n# above theme is added for customization of your docs (optional)\n\nnav:\n  - Home: index.md\n  - React:\n      - Snippets: react/snippets/example-snippet.md\n      - Information: react/information/example-info.md\n  - Bootstrap:\n      - Snippets: bootstrap/snippets/example-snippet.md\n      - Information: bootstrap/information/example-info.md\n  - Tailwind:\n      - Snippets: tailwind/snippets/example-snippet.md\n      - Information: tailwind/information/example-info.md\n  - Virtual Environment:\n      - Snippets: virtual-environment/snippets/create-virtual-env.md\n      - Information: virtual-environment/information/virtual-env-info.md\n  - MkDocs:\n      - Snippets: mkdocs/snippets/example-snippet.md\n      - Information: mkdocs/information/example-info.md\n\nplugins:\n  - search\n  - copy-button\n\nextra:\n  social:\n    - icon: fontawesome/brands/github\n      link: https://github.com/yourusername/yourrepo\n</code></pre>"},{"location":"mkdocs/information/mkdocs-info/#deployment","title":"Deployment","text":"<p>You can deploy your MkDocs site to GitHub Pages using:</p> <pre><code>mkdocs gh-deploy\n</code></pre> <p>For more detailed information, refer to the MkDocs documentation.</p>"},{"location":"mkdocs/snippets/mkdocs-snippet/","title":"MkDocs Setup Snippets","text":""},{"location":"mkdocs/snippets/mkdocs-snippet/#create-folder-structure","title":"Create Folder Structure","text":"<p>Create the following folder structure: (This is the sample structure where <code>docs</code> serve as the main directory and you have to include all the folders inside it. Add <code>mkdocs.yml</code> outside and <code>README.md</code>)</p> <pre><code>documentation-project\n\u251c\u2500\u2500 docs\n\u2502   \u251c\u2500\u2500 mkdocs\n\u2502   \u2502   \u251c\u2500\u2500 snippets\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 example-snippet.md\n\u2502   \u2502   \u2514\u2500\u2500 information\n\u2502   \u2502       \u2514\u2500\u2500 example-info.md\n\u2502   \u251c\u2500\u2500 react\n\u2502   \u2502   \u251c\u2500\u2500 snippets\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 example-snippet.md\n\u2502   \u2502   \u2514\u2500\u2500 information\n\u2502   \u2502       \u2514\u2500\u2500 example-info.md\n\u2502   \u251c\u2500\u2500 bootstrap\n\u2502   \u2502   \u251c\u2500\u2500 snippets\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 example-snippet.md\n\u2502   \u2502   \u2514\u2500\u2500 information\n\u2502   \u2502       \u2514\u2500\u2500 example-info.md\n\u2502   \u251c\u2500\u2500 tailwind\n\u2502   \u2502   \u251c\u2500\u2500 snippets\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 example-snippet.md\n\u2502   \u2502   \u2514\u2500\u2500 information\n\u2502   \u2502       \u2514\u2500\u2500 example-info.md\n\u2502   \u251c\u2500\u2500 virtual-environment\n\u2502   \u2502   \u251c\u2500\u2500 snippets\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 create-virtual-env.md\n\u2502   \u2502   \u2514\u2500\u2500 information\n\u2502   \u2502       \u2514\u2500\u2500 virtual-env-info.md\n\u2502   \u2514\u2500\u2500 index.md\n\u251c\u2500\u2500 mkdocs.yml\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"react/information/example-info/","title":"Example Information about React","text":"<p>React is a JavaScript library for building user interfaces, primarily for single-page applications. It allows developers to create reusable UI components, manage the state of applications, and efficiently update the user interface when data changes.</p>"},{"location":"react/information/example-info/#key-concepts","title":"Key Concepts","text":"<ul> <li> <p>Components: The building blocks of a React application. Components can be functional or class-based and can manage their own state.</p> </li> <li> <p>JSX: A syntax extension that allows writing HTML-like code within JavaScript. JSX makes it easier to create and visualize the structure of the UI.</p> </li> <li> <p>State and Props: State is a built-in object that allows components to create and manage their own data. Props (short for properties) are used to pass data from one component to another.</p> </li> <li> <p>Lifecycle Methods: Special methods that allow you to run code at specific points in a component's life, such as when it mounts, updates, or unmounts.</p> </li> <li> <p>Hooks: Functions that let you use state and other React features in functional components. Common hooks include <code>useState</code>, <code>useEffect</code>, and <code>useContext</code>.</p> </li> </ul>"},{"location":"react/information/example-info/#getting-started","title":"Getting Started","text":"<p>To create a new React application, you can use Create React App, a command-line tool that sets up a new React project with a sensible default configuration.</p> <pre><code>npx create-react-app my-app\ncd my-app\nnpm start\n</code></pre> <p>This will create a new directory called <code>my-app</code> with all the necessary files and dependencies to start building your React application.</p>"},{"location":"react/snippets/example-snippet/","title":"React Example Snippet","text":"<pre><code>// Example of a functional component in React\nimport React from 'react';\n\nconst ExampleComponent = () =&gt; {\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Hello, World!&lt;/h1&gt;\n            &lt;p&gt;This is an example snippet for a React functional component.&lt;/p&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default ExampleComponent;\n</code></pre>"},{"location":"software-engineering/basics/agile-model/","title":"Agile Model &amp; Its Frameworks","text":""},{"location":"software-engineering/basics/agile-model/#what-is-agile","title":"What is Agile?","text":"<p>The Agile Model is an iterative and incremental software development approach that emphasizes:</p> <ul> <li>Customer collaboration over contract negotiation</li> <li>Working software over documentation</li> <li>Responding to change over following a strict plan</li> <li>Continuous delivery &amp; improvement</li> </ul> <p>Unlike the Waterfall model, which follows a strict sequence, Agile is flexible, adaptive, and fast-paced.</p>"},{"location":"software-engineering/basics/agile-model/#phases-of-agile-development","title":"Phases of Agile Development","text":"<p>Agile follows an iterative approach, meaning the software is developed in small increments (sprints or iterations).</p>"},{"location":"software-engineering/basics/agile-model/#1-concept-initiation","title":"1. Concept &amp; Initiation:","text":"<ul> <li>Define project vision and high-level goals.</li> <li>Identify key stakeholders and set expectations.</li> </ul>"},{"location":"software-engineering/basics/agile-model/#2-planning","title":"2. Planning","text":"<ul> <li>Break down requirements into user stories and prioritize them.</li> <li>Plan sprints (typically 1-4 weeks).</li> </ul>"},{"location":"software-engineering/basics/agile-model/#3-design-development","title":"3. Design &amp; Development","text":"<ul> <li>Develop small working features in each sprint.</li> <li>Continuous integration and testing are done simultaneously.</li> </ul>"},{"location":"software-engineering/basics/agile-model/#4-testing-review","title":"4. Testing &amp; Review","text":"<ul> <li>Frequent testing ensures quality.</li> <li>Stakeholders review and provide feedback after each sprint.</li> </ul>"},{"location":"software-engineering/basics/agile-model/#5-release-deployment","title":"5. Release &amp; Deployment","text":"<ul> <li>Each sprint delivers a working software increment to the users.</li> <li>Deployment is done continuously (CI/CD pipeline).</li> </ul>"},{"location":"software-engineering/basics/agile-model/#6-maintenance-continuous-improvement","title":"6. Maintenance &amp; Continuous Improvement","text":"<ul> <li>Gather feedback and improve the next sprint.</li> <li>Monitor performance and apply patches.</li> </ul>"},{"location":"software-engineering/basics/agile-model/#agile-lifecycle","title":"Agile Lifecycle","text":"<pre><code>flowchart TD\nA[Plan] --&gt; B[Design]\nB --&gt; C[Develop]\nC --&gt; D[Test]\nD --&gt; E[Release]\nE --&gt; F[Feedback]\nF --&gt;|Next Sprint| A</code></pre>"},{"location":"software-engineering/basics/agile-model/#agile-frameworks-methodologies","title":"Agile Frameworks &amp; Methodologies","text":"<p>Agile isn\u2019t a single process but has multiple frameworks that implement Agile principles differently. Here are the most popular ones:</p>"},{"location":"software-engineering/basics/agile-model/#1-scrum-most-popular","title":"1. Scrum (Most Popular)","text":"<p>\ud83d\udd39 Best for: Teams working on complex projects with evolving requirements.</p> <p>\ud83d\udd39 Key Features:</p> <ul> <li>Work is divided into Sprints (1-4 weeks).</li> <li>The team follows Daily Stand-up Meetings (15 min).</li> <li>Defined roles: Scrum Master, Product Owner, Development Team.</li> <li>Sprint Review &amp; Retrospective after each sprint.</li> </ul> <p>\ud83d\udd39 Example Use Cases:</p> <ul> <li>Mobile app development (WhatsApp, Instagram).</li> <li>Game development (incremental feature releases).</li> </ul>"},{"location":"software-engineering/basics/agile-model/#scrum-flowchart","title":"Scrum Flowchart","text":"<pre><code>flowchart LR\n    A[Product Backlog] --&gt; B[Sprint Planning]\n    B --&gt; C[Sprint Backlog]\n    C --&gt; D[Daily Scrum]\n    D --&gt; E[Sprint Review]\n    E --&gt; F[Sprint Retrospective]\n    F --&gt;|Next Sprint| B</code></pre>"},{"location":"software-engineering/basics/agile-model/#2-kanban-visual-workflow-management","title":"2. Kanban (Visual Workflow Management)","text":"<p>\ud83d\udd39 Best for: Continuous delivery projects that require real-time tracking.</p> <p>\ud83d\udd39 Key Features:</p> <ul> <li>Uses a Kanban Board to track work progress.</li> <li>Work items move from To Do \u2192 In Progress \u2192 Done.</li> <li>Focus on reducing bottlenecks and improving workflow efficiency.</li> <li>No fixed iterations like Scrum; work is continuously delivered.</li> </ul> <p>\ud83d\udd39 Example Use Cases:</p> <ul> <li>Customer support systems (Zendesk, ServiceNow).</li> <li>Content publishing workflows (Blogs, YouTube video releases).</li> </ul>"},{"location":"software-engineering/basics/agile-model/#kanban-flowchart","title":"Kanban Flowchart","text":"<pre><code>flowchart LR\n    A[To Do] --&gt; B[In Progress]\n    B --&gt; C[Testing]\n    C --&gt; D[Done]</code></pre>"},{"location":"software-engineering/basics/agile-model/#3-extreme-programming-xp-code-focused","title":"3. Extreme Programming (XP) (Code-Focused)","text":"<p>\ud83d\udd39 Best for: High-risk projects that require fast-paced coding &amp; testing.</p> <p>\ud83d\udd39 Key Features:</p> <ul> <li>Test-Driven Development (TDD) \u2013 Write tests before coding.</li> <li>Pair Programming \u2013 Two developers work on the same code together.</li> <li>Continuous Integration (CI) \u2013 Code is frequently merged and tested.</li> <li>Customer involvement in every sprint.</li> </ul> <p>\ud83d\udd39 Example Use Cases:</p> <ul> <li>FinTech applications (real-time transactions, fraud detection).</li> <li>AI and machine learning projects (frequent model tuning).</li> </ul>"},{"location":"software-engineering/basics/agile-model/#xp-flowchart","title":"XP Flowchart","text":"<pre><code>flowchart TD\n    A[User Stories] --&gt; B[Planning]\n    B --&gt; C[Pair Programming]\n    C --&gt; D[Unit Testing]\n    D --&gt; E[Continuous Integration]\n    E --&gt; F[Small Release]\n    F --&gt;|Next Iteration| A\n\n    style C fill:#f9f,stroke:#333\n    style D fill:#f9f,stroke:#333</code></pre>"},{"location":"software-engineering/basics/agile-model/#4-lean-software-development-speed-efficiency","title":"4. Lean Software Development (Speed &amp; Efficiency)","text":"<p>\ud83d\udd39 Best for: Companies that focus on eliminating waste and maximizing value.</p> <p>\ud83d\udd39 Key Features:</p> <ul> <li>Minimize unnecessary work (avoid extra documentation).</li> <li>Automate repetitive tasks.</li> <li>Deliver software as quickly as possible.</li> <li>Encourage team empowerment &amp; decision-making.</li> </ul> <p>\ud83d\udd39 Example Use Cases:</p> <ul> <li>E-commerce platforms (Amazon, Flipkart).</li> <li>Startups building MVPs (Minimum Viable Products).</li> </ul>"},{"location":"software-engineering/basics/agile-model/#comparison-of-agile-frameworks","title":"Comparison of Agile Frameworks","text":"Framework Best For Key Features Examples Scrum Complex projects with evolving needs Sprints, Stand-ups, Scrum Master App &amp; game development Kanban Continuous workflow tracking Kanban Board, real-time updates Support teams, publishing workflows XP (Extreme Programming) Code-intensive projects TDD, Pair Programming, CI/CD FinTech, AI development Lean Fast-paced delivery, efficiency Eliminate waste, optimize flow E-commerce, Startups"},{"location":"software-engineering/basics/agile-model/#advantages","title":"Advantages","text":"<ul> <li>Faster development cycles \u2192 Early &amp; continuous delivery.</li> <li>Customer-focused \u2192 Frequent feedback improves quality.</li> <li>Better risk management \u2192 Issues identified early.</li> <li>Higher team collaboration \u2192 Teams work closely with stakeholders.</li> </ul>"},{"location":"software-engineering/basics/agile-model/#disadvantages","title":"Disadvantages","text":"<ul> <li>Not suitable for all projects \u2192 Works poorly in highly regulated environments (e.g., medical devices).</li> <li>Requires experienced teams \u2192 Needs self-discipline &amp; adaptability.</li> <li>Less predictability \u2192 No fixed deadlines like Waterfall.</li> </ul> <p>Agile Process Diagram Scrum Framework Diagram</p>"},{"location":"software-engineering/basics/sdlc-models-summary/","title":"Comparison between Various SDLC Models","text":"<p>Below is a high-level comparison of several Software Development Life Cycle (SDLC) models.</p> Aspect Waterfall Iterative Spiral Agile V-Models Incremental Development Approach Sequential Iterative Iterative Iterative Iterative Iterative Phases Linear Planning, Design, Coding, Testing, Evaluation (Repeated Iteratively) Planning, Risk Analysis, Engineering, Testing (Cyclical) Planning, Sprint, Review, Retrospective (Iterative Cycles) Planning, Design, Implementation, Testing, Deployment (Parallel) Divided into increments, each with Planning, Implementation, Testing Flexibility Low High High High Moderate High Risk Management Late Proactive Continuous Continuous Moderate Proactive Time-to-Market Longer Faster Variable Faster Moderate Faster User Involvement Limited Continuous Periodic Continuous Periodic Continuous Testing After Implementation Continuous Integrated Continuous After Implementation Continuous Adaptability Low High High High Moderate High Complexity Management Linear Adaptive Cyclical Adaptive Traceability Adaptive"},{"location":"software-engineering/basics/sdlc-models-summary/#when-to-use-which-sdlc-models","title":"When to Use Which SDLC Models?","text":"Consideration Waterfall Iterative Spiral Agile V-Models Incremental Project Size Small-Medium Medium-Large Large Small-Medium Medium-Large Small-Large Project Complexity Low-Medium Medium-High High Low-High Medium-High Medium-High Requirements Stability Stable Evolving Evolving Changing Moderate Stable-Moderate Client Involvement Limited Continuous Periodic High Periodic Continuous Budget Constraints Fixed Some Flexibility Flexible Variable Fixed Some Flexibility Risk Tolerance Low Moderate High Moderate Moderate Moderate-High Time-to-Market Moderate Faster Variable Faster Moderate Faster Documentation Emphasis Extensive Moderate Detailed Minimal Moderate Moderate Testing Approach Sequential Continuous Continuous Continuous After Phases Continuous Change Management Limited High Adaptive Highly Adaptive Moderate High"},{"location":"software-engineering/basics/sdlc-models-summary/#most-widely-used-sdlc-model","title":"Most Widely Used SDLC Model","text":"<p>Agile is the most widely used SDLC model due to its adaptability, customer satisfaction, faster time-to-market, effective risk management, collaborative environment, continuous improvement, iterative development, and sustainable pace.</p>"},{"location":"software-engineering/basics/sdlc-models/","title":"SDLC Models","text":"<p>An SDLC model is a systematic approach to the software development process that defines the stages and tasks involved in building software. It serves as a guide for planning, structuring, and controlling the process of developing information systems.</p>"},{"location":"software-engineering/basics/sdlc-models/#i-waterfall-model","title":"(i) Waterfall Model","text":"<ul> <li>The Waterfall model follows a linear and sequential approach to software development. Each phase in the development process must be completed before moving on to the next one, resembling the downward flow of a waterfall.</li> </ul> <pre><code>flowchart TD\n    A[Requirements] --&gt; B[Design]\n    B --&gt; C[Implementation/Development]\n    C --&gt; D[Verification/Testing]\n    D --&gt; E[Deployment]\n    E --&gt; F[Maintenance]</code></pre> <p>Advantages</p> <ul> <li>Easy to understand and manage</li> <li>Suitable for small projects with well-defined requirements at the beginning</li> </ul> <p>Disadvantages</p> <ul> <li>Inflexible to changes</li> <li>Testing happens late</li> <li>Limited client feedback</li> <li>No early prototypes</li> </ul>"},{"location":"software-engineering/basics/sdlc-models/#ii-iterative-model","title":"(ii) Iterative Model","text":"<p>The Iterative model develops a system through repeated cycles (iterations) and in smaller portions at a time.</p> <pre><code>flowchart TD\n    A[Initial Planning/Initialization] --&gt; B[Planning]\n    B --&gt; C[Requirements]\n    C --&gt; D[Analysis &amp; Design]\n    D --&gt; E[Implementation]\n    E --&gt; F[Testing]\n    F --&gt; G[Evaluation]\n    G --&gt;|Next Iteration| B</code></pre> <p>Advantages</p> <ul> <li>Early working version</li> <li>Flexible to changes</li> <li>Risks identified early</li> <li>Regular customer feedback</li> <li>Better risk management</li> </ul> <p>Disadvantages</p> <ul> <li>More management complexity</li> <li>Needs active customer involvement</li> <li>May extend project timeline</li> <li>Documentation challenges</li> </ul>"},{"location":"software-engineering/basics/sdlc-models/#iii-v-model-verification-and-validation-model","title":"(iii) V-Model (Verification and Validation Model)","text":"<p>The V-Model extends the waterfall model by emphasizing testing for each corresponding development stage. Each development stage has a directly associated testing phase.</p> <ul> <li>By integrating verification and validation activities in parallel, this model aims to deliver high-quality software while mitigating the risk of defects.</li> </ul> <pre><code>graph TD\n    A[Requirements] --&gt; F[Acceptance Testing]\n    B[System Design] --&gt; G[System Testing]\n    C[Architecture Design] --&gt; H[Integration Testing]\n    D[Module Design] --&gt; I[Module Testing]\n    E[Coding]\n\n    A --&gt; B\n    B --&gt; C\n    C --&gt; D\n    D --&gt; E\n    F --&gt; G\n    G --&gt; H\n    H --&gt; I\n    I --&gt; E\n\n    style A fill:#f9f,stroke:#333,stroke-width:2px\n    style F fill:#f9f,stroke:#333,stroke-width:2px\n    style E fill:#444,stroke:#444,stroke-width:2px</code></pre> <p>Advantages</p> <ul> <li>Systematic testing</li> <li>Clear deliverables</li> <li>Easy to manage</li> <li>Strong documentation</li> </ul> <p>Disadvantages</p> <ul> <li>Rigid structure</li> <li>No early prototypes</li> <li>High cost of testing</li> <li>Long development cycle</li> </ul>"},{"location":"software-engineering/basics/sdlc-models/#iv-evolutionary-models","title":"(iv) Evolutionary Models","text":"<ul> <li>Evolutionary Models are iterative.</li> </ul>"},{"location":"software-engineering/basics/sdlc-models/#1-prototyping-model","title":"1. Prototyping Model","text":"<p>A software development model where a prototype is built, tested, and refined until it meets client requirements.</p> <pre><code>flowchart TD\n    A[Initial Requirements] --&gt; B[Build Prototype]\n    B --&gt; C[Review]\n    C --&gt; D[Refine Requirements]\n    D --&gt;|Not Satisfied| B\n    D --&gt;|Satisfied| E[Development]\n    E --&gt; F[Testing]\n    F --&gt; G[Maintenance]</code></pre> <p>Best Used For</p> <ul> <li>User interface designs</li> <li>Online systems</li> <li>Web applications</li> <li>Mobile apps</li> </ul> <p>Advantages</p> <ul> <li>Early user feedback</li> <li>Clear requirements</li> <li>Reduced risk</li> <li>Better user satisfaction</li> </ul> <p>Disadvantages</p> <ul> <li>Time-consuming</li> <li>Increased cost</li> <li>Client confusion</li> <li>Incomplete documentation</li> </ul>"},{"location":"software-engineering/basics/sdlc-models/#2-spiral-model","title":"2. Spiral Model","text":"<p>The Spiral Model combines aspects of both waterfall and prototyping models, emphasizing risk analysis throughout each iteration.</p> <pre><code>flowchart LR\n    subgraph \"Iteration 1\"\n        A1[Planning] --&gt; B1[Risk Analysis]\n        B1 --&gt; C1[Engineering]\n        C1 --&gt; D1[Evaluation]\n        D1 --&gt; A2\n    end\n\n    subgraph \"Iteration 2\"\n        A2[Planning] --&gt; B2[Risk Analysis]\n        B2 --&gt; C2[Engineering]\n        C2 --&gt; D2[Evaluation]\n        D2 --&gt; A3\n    end\n\n    subgraph \"Iteration 3\"\n        A3[Planning] --&gt; B3[Risk Analysis]\n        B3 --&gt; C3[Engineering]\n        C3 --&gt; D3[Evaluation]\n    end</code></pre> <pre><code>graph TD\n    A[Planning] --&gt; B[Risk Analysis]\n    B --&gt; C[Engineering]\n    C --&gt; D[Evaluation]\n    D --&gt; A</code></pre> <ul> <li>continuous iteration of the above step....</li> </ul> <p>Four Phases per Spiral</p> <ul> <li> <p>Planning :   Objectives,   Alternatives,   Constraints,   Risk Analysis</p> </li> <li> <p>Identify risks:   Risk mitigation,   Prototyping,   Engineering</p> </li> <li> <p>Development:   Testing,   Verification,</p> </li> <li>Evaluation:   Review results,   Plan next iteration,   Decision to continue</li> </ul> <p>Best Used For:</p> <ul> <li>Large, high-risk projects</li> <li>Projects needing early user feedback</li> <li>Complex systems with unclear requirements Example: New Operating System Development</li> </ul> <p>Advantages</p> <ul> <li>High risk management</li> <li>Early prototypes</li> <li>Flexible to changes</li> <li>Regular customer feedback</li> </ul> <p>Disadvantages</p> <ul> <li>Complex management</li> <li>High documentation</li> <li>Expensive for small projects</li> <li>Needs risk assessment expertise</li> </ul>"},{"location":"software-engineering/basics/sdlc-models/#v-incremental-model","title":"(v) Incremental Model","text":"<p>Develops software in increments, with each increment adding new functionality to the previous version.</p>"},{"location":"software-engineering/basics/sdlc-models/#development-cycle","title":"Development Cycle","text":"<pre><code>flowchart TD\n        A[Requirements] --&gt;|Build 1| B1[Design]\n    subgraph \"Increment 1\"\n\n        B1 --&gt; C1[Code]\n        C1 --&gt; D1[Test]\n        D1 --&gt; E1[Release v1]\n    end\n\n    subgraph \"Increment 2\"\n        B2[Design] --&gt; C2[Code]\n        C2 --&gt; D2[Test]\n        D2 --&gt; E2[Release v2]\n    end\n\n    A --&gt;|Build 2| B2</code></pre> <p>Key Features</p> <ul> <li>Multiple Development Cycles</li> <li>Partial Systems</li> <li>Prioritized Development</li> <li>Parallel Development</li> </ul> <p>Advantages</p> <ul> <li>Early functional software</li> <li>Flexible scheduling</li> <li>Easy to test</li> <li>Risk management</li> </ul> <p>Disadvantages</p> <ul> <li>Interface challenges</li> <li>Need good planning</li> <li>System architecture issues</li> <li>Documentation overhead</li> </ul>"},{"location":"software-engineering/basics/sdlc-models/#vi-agile-model","title":"(vi) Agile Model","text":"<p>Agile is an iterative approach that focuses on collaboration, customer feedback, and rapid releases.</p>"},{"location":"software-engineering/basics/sdlc-models/#sprint-cycle","title":"Sprint Cycle","text":"<pre><code>flowchart TD\n    A[Sprint Planning] --&gt; B[Daily Standups]\n    B --&gt; C[Development]\n    C --&gt; D[Testing]\n    D --&gt; E[Sprint Review]\n    E --&gt; F[Sprint Retrospective]\n    F --&gt;|Next Sprint| A\n\n    style A fill:#f9f,stroke:#333\n    style E fill:#f9f,stroke:#333\n    style F fill:#f9f,stroke:#333</code></pre>"},{"location":"software-engineering/basics/sdlc/","title":"Software Development Life Cycle (SDLC)","text":""},{"location":"software-engineering/basics/sdlc/#what-is-sdlc","title":"What is SDLC?","text":"<p>The Software Development Life Cycle (SDLC) is a systematic process for building software applications that ensures their quality and correctness. The SDLC process aims to produce high-quality software that meets customer expectations and completes development within time and cost estimates.</p> <pre><code>graph TD\n    A[Planning] --&gt;|Requirements Gathered| B[Analysis]\n    B --&gt;|Requirements Defined| C[Design]\n    C --&gt;|Architecture Created| D[Implementation]\n    D --&gt;|Code Developed| E[Testing]\n    E --&gt;|Software Verified| F[Deployment]\n    F --&gt;|Live Release| G[Maintenance]\n    G --&gt;|Updates Required| A</code></pre>"},{"location":"software-engineering/basics/sdlc/#key-objectives","title":"Key Objectives","text":"<ul> <li>Deliver high-quality software</li> <li>Meet customer expectations</li> <li>Complete within timeline and budget</li> <li>Follow best practices and standards</li> </ul>"},{"location":"software-engineering/basics/sdlc/#sdlc-stages","title":"SDLC Stages","text":""},{"location":"software-engineering/basics/sdlc/#1-planning-and-requirement-analysis","title":"1. Planning and Requirement Analysis","text":"<pre><code>flowchart TD\n    A[Gather Requirements] --&gt; B[Analyze Requirements]\n    B --&gt; C[Document Requirements]\n    C --&gt; D[Validate Requirements]\n    D --&gt; E[Create Project Plan]</code></pre>"},{"location":"software-engineering/basics/sdlc/#2-defining-requirements","title":"2. Defining Requirements","text":"<pre><code>flowchart LR\n    A[Business Requirements] --&gt; B[Technical Requirements]\n    B --&gt; C[Functional Requirements]\n    C --&gt; D[Non-Functional Requirements]\n    D --&gt; E[SRS Document]</code></pre> <ul> <li>This is fulfilled by utilizing SRS (Software Requirement Specification). This is a sort of document that specifies all those things that need to be defined and created during the entire project cycle.</li> </ul>"},{"location":"software-engineering/basics/sdlc/#3-system-design","title":"3. System Design","text":""},{"location":"software-engineering/basics/sdlc/#two-approaches-to-system-design","title":"Two approaches to System Design:","text":"<ol> <li> <p>Top-Down Approach (High Level \u2192 Low Level)</p> </li> <li> <p>Start with overall system architecture</p> </li> <li>Break down into smaller components</li> <li> <p>Good for understanding big picture first</p> </li> <li> <p>Bottom-Up Approach (Low Level \u2192 High Level)</p> </li> <li>Start with detailed components</li> <li>Combine into larger systems</li> <li>Good for understanding implementation details first</li> </ol>"},{"location":"software-engineering/basics/sdlc/#design-hierarchy","title":"Design Hierarchy:","text":"<pre><code>graph TD\n   A[Requirements Analysis] --&gt; B[Low Level Design]\n        B --&gt; C[High Level Design]\n        C --&gt; D[System Architecture]</code></pre> <pre><code>graph TD\n    subgraph \"System Design\"\n\n        subgraph \"Low Level Design\"\n            B1[Class Design]\n            B2[Algorithm Details]\n            B3[Data Structures]\n        end\n\n        subgraph \"High Level Design\"\n            C1[Component Design]\n            C2[Interface Design]\n            C3[Database Design]\n        end\n\n        subgraph \"System Architecture\"\n            D1[Overall Structure]\n            D2[System Integration]\n            D3[Deployment Plan]\n        end\n    end</code></pre> <ul> <li>SRS is a reference for software designers to come up with the best architecture for the software. Hence, with the requirements defined in SRS, multiple designs for the product architecture are present in the Design Document Specification (DDS).</li> </ul>"},{"location":"software-engineering/basics/sdlc/#4-implementation","title":"4. Implementation","text":"<ul> <li>At this stage, the fundamental development of the product starts. For this, developers use a specific programming code as per the design in the DDS.</li> <li>Programming tools like compilers, interpreters, debuggers, etc. and languages like C/C++, Python, Java etc. are also put into use at this stage.</li> </ul> <pre><code>flowchart LR\n    A[Code Development] --&gt; B[Code Review]\n    B --&gt; C[Unit Testing]\n    C --&gt; D[Integration]</code></pre>"},{"location":"software-engineering/basics/sdlc/#5-testing-and-integration","title":"5. Testing and Integration","text":"<pre><code>flowchart TD\n    A[Unit Testing] --&gt; B[Integration Testing]\n    B --&gt; C[System Testing]\n    C --&gt; D[Acceptance Testing]\n    D --&gt; E[Performance Testing]</code></pre>"},{"location":"software-engineering/basics/sdlc/#6-deployment","title":"6. Deployment","text":"<pre><code>flowchart LR\n    A[Build Release] --&gt; B[Deploy to Staging]\n    B --&gt; C[User Acceptance]\n    C --&gt; D[Production Deployment]</code></pre>"},{"location":"software-engineering/basics/sdlc/#7-maintenance","title":"7. Maintenance","text":"<pre><code>flowchart TD\n    A[Monitor System] --&gt; B[Bug Fixes]\n    B --&gt; C[Updates]\n    C --&gt; D[Enhancements]\n    D --&gt; A</code></pre> <p>Reference: Click here</p>"},{"location":"software-engineering/basics/software-software_engineering/","title":"Software and Software Engineering","text":""},{"location":"software-engineering/basics/software-software_engineering/#software","title":"Software","text":"<p>Software is a set of programs and data that instructs a computer to perform tasks. It enables hardware to function and allows user interaction.</p>"},{"location":"software-engineering/basics/software-software_engineering/#types-of-software","title":"Types of Software","text":"<ul> <li>System Software: Manages hardware and provides a platform for other software (e.g., operating systems like Windows, macOS, Linux).</li> <li>Application Software: Designed for end-users to perform specific tasks (e.g., web browsers, media players, office suites).</li> <li>Programming Software: Provides tools for developers to write, test, and debug code (e.g., compilers, text editors, IDEs).</li> <li>Middleware: Acts as a bridge between different applications and system software.</li> </ul>"},{"location":"software-engineering/basics/software-software_engineering/#software-engineering","title":"Software Engineering","text":"<p>Software Engineering involves designing, developing, testing, and maintaining software systematically to ensure quality and reliability.</p>"},{"location":"software-engineering/basics/software-software_engineering/#key-principles","title":"Key Principles","text":"<ul> <li>Modularity: Break software into smaller parts.</li> <li>Abstraction: Hide implementation details.</li> <li>Encapsulation: Protect internal state.</li> <li>Reusability: Use components in multiple projects.</li> <li>Maintenance: Regular updates and improvements.</li> <li>Testing: Ensure software meets requirements.</li> <li>Design Patterns: Templates for solving design problems.</li> <li>Agile Methodologies: Iterative development focused on customer satisfaction.</li> <li>Continuous Integration &amp; Deployment: Regularly integrate and deploy code.</li> </ul>"},{"location":"software-engineering/basics/software-software_engineering/#main-attributes","title":"Main Attributes","text":"<ul> <li>Efficiency: Resource usage.</li> <li>Reliability: Consistent performance.</li> <li>Reusability: Use in multiple applications.</li> <li>Maintainability: Easy to modify and enhance.</li> </ul>"},{"location":"software-engineering/basics/software-software_engineering/#dual-role-of-software","title":"Dual Role of Software","text":"<ol> <li>As a Product: Enables hardware functionality and information processing.</li> <li>As a Vehicle for Delivering a Product: Provides system functionality and helps build other software.</li> </ol>"},{"location":"software-engineering/basics/software-software_engineering/#objectives","title":"Objectives","text":"<ul> <li>Maintainability: Adapt to changes.</li> <li>Efficiency: Optimal resource use.</li> <li>Correctness: Meets requirements.</li> <li>Reusability: Easy module reuse.</li> <li>Testability: Facilitate testing.</li> <li>Reliability: Consistent function.</li> <li>Portability: Transferable across systems.</li> <li>Adaptability: Satisfy varying needs.</li> <li>Interoperability: Cooperative data processing.</li> </ul>"},{"location":"software-engineering/basics/software-software_engineering/#program-vs-software-product","title":"Program vs Software Product","text":"Parameters Program Software Product Definition Instructions for a task. Commercially available, documented, licensed. Stages Involved Single stage. Full life cycle: feasibility, requirements, design, coding, testing. <ul> <li> <p>A program is a set of instructions that are given to a computer in order to achieve a specific task.</p> </li> <li> <p>Software is when a program is made available for commercial business and is properly documented along with its licensing.</p> </li> </ul>"},{"location":"software-engineering/basics/software-software_engineering/#advantages","title":"Advantages","text":"<ul> <li>Improved Quality: Fewer bugs.</li> <li>Increased Productivity: Streamlined process.</li> <li>Better Maintainability: Easier updates.</li> <li>Reduced Costs: Early problem detection.</li> <li>Increased Customer Satisfaction: Meets needs.</li> <li>Better Team Collaboration: Agile methods.</li> <li>Better Scalability: Designed for growth.</li> <li>Better Security: Prevents breaches.</li> </ul>"},{"location":"software-engineering/basics/software-software_engineering/#disadvantages","title":"Disadvantages","text":"<ul> <li>High Upfront Costs: Investment needed.</li> <li>Limited Flexibility: Slow adaptation.</li> <li>Bureaucratic: Slows development.</li> <li>Complexity: Hard to navigate.</li> <li>Limited Creativity: Structured approach.</li> <li>High Learning Curve: Extensive training.</li> <li>Tool Dependence: Issues with tools.</li> <li>High Maintenance: Costly upkeep.</li> </ul> <p>In summary, software engineering provides a structured approach to develop high-quality, maintainable software, improving customer satisfaction and reducing costs.</p> <p>Reference : Click here</p>"},{"location":"virtual-environment/information/virtual-env-info/","title":"Virtual Environments","text":"<p>Virtual environments are isolated environments that allow you to manage dependencies for different projects separately. They are particularly useful in Python development, where different projects may require different versions of libraries.</p>"},{"location":"virtual-environment/information/virtual-env-info/#purpose-of-virtual-environments","title":"Purpose of Virtual Environments","text":"<ol> <li>Dependency Management: Virtual environments help manage project-specific dependencies without affecting the global Python installation.</li> <li>Version Control: You can maintain different versions of libraries for different projects, ensuring compatibility and stability.</li> <li>Isolation: Each virtual environment is self-contained, preventing conflicts between packages used in different projects.</li> </ol>"},{"location":"virtual-environment/information/virtual-env-info/#common-tools-for-creating-virtual-environments","title":"Common Tools for Creating Virtual Environments","text":"<ul> <li>venv: A built-in module in Python 3 that allows you to create lightweight virtual environments.</li> <li>virtualenv: A third-party tool that provides more features and supports older versions of Python.</li> <li>conda: A package manager that can create virtual environments and manage packages for Python and other languages.</li> </ul>"},{"location":"virtual-environment/information/virtual-env-info/#basic-commands","title":"Basic Commands","text":""},{"location":"virtual-environment/information/virtual-env-info/#using-venv","title":"Using <code>venv</code>","text":"<ol> <li> <p>Create a Virtual Environment:    <pre><code>python -m venv myenv\n</code></pre></p> </li> <li> <p>Activate the Virtual Environment:</p> </li> <li>On Windows:      <pre><code>myenv\\Scripts\\activate\n</code></pre></li> <li> <p>On macOS/Linux:      <pre><code>source myenv/bin/activate\n</code></pre></p> </li> <li> <p>Deactivate the Virtual Environment:    <pre><code>deactivate\n</code></pre></p> </li> </ol>"},{"location":"virtual-environment/information/virtual-env-info/#using-virtualenv","title":"Using <code>virtualenv</code>","text":"<ol> <li> <p>Install virtualenv (if not already installed):    <pre><code>pip install virtualenv\n</code></pre></p> </li> <li> <p>Create a Virtual Environment:    <pre><code>virtualenv myenv\n</code></pre></p> </li> <li> <p>Activate and Deactivate: Same as above.</p> </li> </ol>"},{"location":"virtual-environment/information/virtual-env-info/#using-conda","title":"Using <code>conda</code>","text":"<ol> <li> <p>Create a Virtual Environment:    <pre><code>conda create --name myenv\n</code></pre></p> </li> <li> <p>Activate the Virtual Environment:    <pre><code>conda activate myenv\n</code></pre></p> </li> <li> <p>Deactivate the Virtual Environment:    <pre><code>conda deactivate\n</code></pre></p> </li> </ol>"},{"location":"virtual-environment/information/virtual-env-info/#conclusion","title":"Conclusion","text":"<p>Using virtual environments is a best practice in software development, especially for Python projects. They help maintain clean and manageable project dependencies, making it easier to work on multiple projects simultaneously.</p>"},{"location":"virtual-environment/snippets/create-virtual-env/","title":"Creating a Virtual Environment","text":""},{"location":"virtual-environment/snippets/create-virtual-env/#python","title":"Python","text":"<p>To create a virtual environment in Python, follow these steps:</p> <ol> <li> <p>Install <code>virtualenv</code> (if not already installed): <code>pip install virtualenv</code></p> </li> <li> <p>Navigate to your project directory: <code>cd your-project-directory</code></p> </li> <li> <p>Create a virtual environment: <code>virtualenv venv</code></p> </li> <li> <p>Activate the virtual environment:</p> </li> <li> <p>On Windows:      <pre><code>venv\\Scripts\\activate\n</code></pre></p> </li> <li> <p>On macOS/Linux:      <pre><code>source venv/bin/activate\n</code></pre></p> </li> <li> <p>Deactivate the virtual environment when done:    <pre><code>deactivate\n</code></pre></p> </li> </ol>"},{"location":"virtual-environment/snippets/create-virtual-env/#nodejs","title":"Node.js","text":"<p>To create a virtual environment in Node.js, you can use <code>nvm</code> (Node Version Manager):</p> <ol> <li> <p>Install <code>nvm</code> (if not already installed):    Follow the installation instructions from the nvm repository.</p> </li> <li> <p>Install a specific Node.js version: <code>nvm install &lt;version&gt;</code></p> </li> <li> <p>Use the installed version: <code>nvm use &lt;version&gt;</code></p> </li> <li> <p>Deactivate the version: <code>nvm deactivate</code></p> </li> </ol>"}]}