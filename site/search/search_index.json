{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to My Docs","text":"<p>This is the personal documentation site of Rajat Bhati.</p>"},{"location":"#about-me","title":"About Me","text":"<ul> <li>GitHub: https://github.com/Rajatt09</li> <li>LinkedIn: https://www.linkedin.com/in/rajatbhati</li> <li>Email: rajatbhati9559@gmail.com</li> </ul>"},{"location":"#documentation","title":"Documentation","text":"<p>This site contains documentation for various tools and technologies that I use. It includes snippets and information that I refer to occasionally.</p>"},{"location":"mkdocs/information/mkdocs-info/","title":"MkDocs Setup Information","text":""},{"location":"mkdocs/information/mkdocs-info/#introduction","title":"Introduction","text":"<p>MkDocs is a static site generator that's geared towards project documentation. It is written in Python and is easy to configure and deploy.</p>"},{"location":"mkdocs/information/mkdocs-info/#installation","title":"Installation","text":"<p>To install MkDocs, use the following command:</p> <pre><code>pip install mkdocs\n</code></pre>"},{"location":"mkdocs/information/mkdocs-info/#creating-a-new-project","title":"Creating a New Project","text":"<p>To create a new MkDocs project, run:</p> <pre><code>mkdocs new my-project\ncd my-project\n</code></pre>"},{"location":"mkdocs/information/mkdocs-info/#running-the-project","title":"Running the Project","text":"<p>To start the live-reloading docs server, use:</p> <pre><code>mkdocs serve\n</code></pre> <p>You can then view the documentation at <code>http://127.0.0.1:8000/</code>.</p>"},{"location":"mkdocs/information/mkdocs-info/#building-the-documentation","title":"Building the Documentation","text":"<p>To build the documentation, run:</p> <pre><code>mkdocs build\n</code></pre> <p>This will create a <code>site</code> directory with your static site.</p>"},{"location":"mkdocs/information/mkdocs-info/#configuration","title":"Configuration","text":"<p>The configuration file <code>mkdocs.yml</code> is where you configure your MkDocs project. Here is an example configuration:</p> <pre><code># filepath: myDocs/my-project/mkdocs.yml\nsite_name: My Documentation Project\ntheme:\n  name: material\n  custom_dir: docs/overrides\n\n# above theme is added for customization of your docs (optional)\n\nnav:\n  - Home: index.md\n  - React:\n      - Snippets: react/snippets/example-snippet.md\n      - Information: react/information/example-info.md\n  - Bootstrap:\n      - Snippets: bootstrap/snippets/example-snippet.md\n      - Information: bootstrap/information/example-info.md\n  - Tailwind:\n      - Snippets: tailwind/snippets/example-snippet.md\n      - Information: tailwind/information/example-info.md\n  - Virtual Environment:\n      - Snippets: virtual-environment/snippets/create-virtual-env.md\n      - Information: virtual-environment/information/virtual-env-info.md\n  - MkDocs:\n      - Snippets: mkdocs/snippets/example-snippet.md\n      - Information: mkdocs/information/example-info.md\n\nplugins:\n  - search\n  - copy-button\n\nextra:\n  social:\n    - icon: fontawesome/brands/github\n      link: https://github.com/yourusername/yourrepo\n</code></pre>"},{"location":"mkdocs/information/mkdocs-info/#deployment","title":"Deployment","text":"<p>You can deploy your MkDocs site to GitHub Pages using:</p> <pre><code>mkdocs gh-deploy\n</code></pre> <p>For more detailed information, refer to the MkDocs documentation.</p>"},{"location":"mkdocs/snippets/mkdocs-snippet/","title":"MkDocs Setup Snippets","text":""},{"location":"mkdocs/snippets/mkdocs-snippet/#create-folder-structure","title":"Create Folder Structure","text":"<p>Create the following folder structure: (This is the sample structure where <code>docs</code> serve as the main directory and you have to include all the folders inside it. Add <code>mkdocs.yml</code> outside and <code>README.md</code>)</p> <pre><code>documentation-project\n\u251c\u2500\u2500 docs\n\u2502   \u251c\u2500\u2500 mkdocs\n\u2502   \u2502   \u251c\u2500\u2500 snippets\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 example-snippet.md\n\u2502   \u2502   \u2514\u2500\u2500 information\n\u2502   \u2502       \u2514\u2500\u2500 example-info.md\n\u2502   \u251c\u2500\u2500 react\n\u2502   \u2502   \u251c\u2500\u2500 snippets\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 example-snippet.md\n\u2502   \u2502   \u2514\u2500\u2500 information\n\u2502   \u2502       \u2514\u2500\u2500 example-info.md\n\u2502   \u251c\u2500\u2500 bootstrap\n\u2502   \u2502   \u251c\u2500\u2500 snippets\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 example-snippet.md\n\u2502   \u2502   \u2514\u2500\u2500 information\n\u2502   \u2502       \u2514\u2500\u2500 example-info.md\n\u2502   \u251c\u2500\u2500 tailwind\n\u2502   \u2502   \u251c\u2500\u2500 snippets\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 example-snippet.md\n\u2502   \u2502   \u2514\u2500\u2500 information\n\u2502   \u2502       \u2514\u2500\u2500 example-info.md\n\u2502   \u251c\u2500\u2500 virtual-environment\n\u2502   \u2502   \u251c\u2500\u2500 snippets\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 create-virtual-env.md\n\u2502   \u2502   \u2514\u2500\u2500 information\n\u2502   \u2502       \u2514\u2500\u2500 virtual-env-info.md\n\u2502   \u2514\u2500\u2500 index.md\n\u251c\u2500\u2500 mkdocs.yml\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"react/information/example-info/","title":"Example Information about React","text":"<p>React is a JavaScript library for building user interfaces, primarily for single-page applications. It allows developers to create reusable UI components, manage the state of applications, and efficiently update the user interface when data changes.</p>"},{"location":"react/information/example-info/#key-concepts","title":"Key Concepts","text":"<ul> <li> <p>Components: The building blocks of a React application. Components can be functional or class-based and can manage their own state.</p> </li> <li> <p>JSX: A syntax extension that allows writing HTML-like code within JavaScript. JSX makes it easier to create and visualize the structure of the UI.</p> </li> <li> <p>State and Props: State is a built-in object that allows components to create and manage their own data. Props (short for properties) are used to pass data from one component to another.</p> </li> <li> <p>Lifecycle Methods: Special methods that allow you to run code at specific points in a component's life, such as when it mounts, updates, or unmounts.</p> </li> <li> <p>Hooks: Functions that let you use state and other React features in functional components. Common hooks include <code>useState</code>, <code>useEffect</code>, and <code>useContext</code>.</p> </li> </ul>"},{"location":"react/information/example-info/#getting-started","title":"Getting Started","text":"<p>To create a new React application, you can use Create React App, a command-line tool that sets up a new React project with a sensible default configuration.</p> <pre><code>npx create-react-app my-app\ncd my-app\nnpm start\n</code></pre> <p>This will create a new directory called <code>my-app</code> with all the necessary files and dependencies to start building your React application.</p>"},{"location":"react/snippets/example-snippet/","title":"React Example Snippet","text":"<pre><code>// Example of a functional component in React\nimport React from 'react';\n\nconst ExampleComponent = () =&gt; {\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Hello, World!&lt;/h1&gt;\n            &lt;p&gt;This is an example snippet for a React functional component.&lt;/p&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default ExampleComponent;\n</code></pre>"},{"location":"software-engineering/architecture/microservices/","title":"Microservices","text":""},{"location":"software-engineering/architecture/microservices/#benefits-of-microservices","title":"Benefits of Microservices","text":"<ol> <li>Scalability: Each service can be scaled independently based on its demand, allowing for more efficient resource utilization.</li> <li>Flexibility in Technology: Different services can be built using different programming languages or technologies, enabling teams to choose the best tools for each job.</li> <li>Improved Fault Isolation: If one service fails, it does not necessarily bring down the entire application, enhancing overall system reliability.</li> <li>Faster Time to Market: Smaller, independent teams can work on different services simultaneously, speeding up the development process.</li> </ol>"},{"location":"software-engineering/architecture/microservices/#challenges-of-microservices","title":"Challenges of Microservices","text":"<ol> <li>Complexity: Managing multiple services can introduce complexity in terms of deployment, monitoring, and communication between services.</li> <li>Data Management: Ensuring data consistency across services can be challenging, especially when using different databases.</li> <li>Network Latency: Communication between services over a network can introduce latency, affecting performance.</li> <li>Deployment Overhead: Each service may require its own deployment pipeline, increasing the overhead of managing deployments.</li> </ol>"},{"location":"software-engineering/architecture/microservices/#conclusion","title":"Conclusion","text":"<p>Microservices architecture offers significant advantages for building scalable and maintainable applications, but it also requires careful consideration of the associated challenges. Proper planning and the right tools can help mitigate these challenges and leverage the benefits of microservices effectively.</p>"},{"location":"software-engineering/architecture/system-design/","title":"system-design.md","text":""},{"location":"software-engineering/architecture/system-design/#system-design","title":"System Design","text":"<p>System design is a crucial aspect of software engineering that focuses on how to build scalable and efficient systems. Here are some key concepts to understand:</p>"},{"location":"software-engineering/architecture/system-design/#1-scalability","title":"1. Scalability","text":"<p>Scalability refers to the ability of a system to handle increased load without compromising performance. There are two types of scalability: - Vertical Scaling: Adding more power (CPU, RAM) to an existing machine. - Horizontal Scaling: Adding more machines to distribute the load.</p>"},{"location":"software-engineering/architecture/system-design/#2-performance","title":"2. Performance","text":"<p>Performance is about how quickly a system responds to requests. Key factors affecting performance include: - Latency: The time it takes to process a request. - Throughput: The number of requests a system can handle in a given time frame.</p>"},{"location":"software-engineering/architecture/system-design/#3-load-balancing","title":"3. Load Balancing","text":"<p>Load balancing distributes incoming network traffic across multiple servers to ensure no single server becomes overwhelmed. This improves responsiveness and availability.</p>"},{"location":"software-engineering/architecture/system-design/#4-caching","title":"4. Caching","text":"<p>Caching stores frequently accessed data in memory to reduce the time it takes to retrieve it. This can significantly improve performance.</p>"},{"location":"software-engineering/architecture/system-design/#5-database-design","title":"5. Database Design","text":"<p>Choosing the right database and designing it effectively is crucial for system performance. Considerations include: - Normalization: Organizing data to reduce redundancy. - Indexing: Creating indexes to speed up data retrieval.</p>"},{"location":"software-engineering/architecture/system-design/#6-microservices","title":"6. Microservices","text":"<p>Microservices architecture breaks down applications into smaller, independent services that can be developed, deployed, and scaled individually.</p>"},{"location":"software-engineering/architecture/system-design/#7-api-design","title":"7. API Design","text":"<p>Designing clear and efficient APIs is essential for enabling communication between different parts of a system or between different systems.</p> <p>Understanding these concepts will help you design systems that are robust, scalable, and maintainable.</p>"},{"location":"software-engineering/basics/agile-model/","title":"Agile Model","text":""},{"location":"software-engineering/basics/agile-model/#what-is-agile","title":"What is Agile?","text":"<p>Iterative approach focusing on collaboration, customer feedback, and rapid delivery.</p>"},{"location":"software-engineering/basics/agile-model/#core-principles","title":"Core Principles","text":"<pre><code>mindmap\n    root((Agile))\n        Customer First\n            Regular Feedback\n            Collaboration\n        Working Software\n            Quick Delivery\n            Small Releases\n        Team Focus\n            Self-organizing\n            Face-to-face\n        Adapt to Change\n            Flexible Planning\n            Welcome Changes</code></pre>"},{"location":"software-engineering/basics/agile-model/#agile-lifecycle","title":"Agile Lifecycle","text":"<pre><code>flowchart TD\n        A[Plan] --&gt; B[Design]\n        B --&gt; C[Develop]\n        C --&gt; D[Test]\n        D --&gt; E[Release]\n        E --&gt; F[Feedback]\n        F --&gt;|Next Sprint| A</code></pre>"},{"location":"software-engineering/basics/agile-model/#popular-frameworks","title":"Popular Frameworks","text":""},{"location":"software-engineering/basics/agile-model/#1-scrum-framework","title":"1. Scrum Framework","text":"<pre><code>flowchart LR\n        A[Product Backlog] --&gt; B[Sprint Planning]\n        B --&gt; C[Sprint Backlog]\n        C --&gt; D[Daily Scrum]\n        D --&gt; E[Sprint Review]\n        E --&gt; F[Sprint Retrospective]\n        F --&gt;|Next Sprint| B</code></pre>"},{"location":"software-engineering/basics/agile-model/#2-kanban-board","title":"2. Kanban Board","text":"<pre><code>flowchart LR\n        A[To Do] --&gt; B[In Progress]\n        B --&gt; C[Testing]\n        C --&gt; D[Done]</code></pre>"},{"location":"software-engineering/basics/agile-model/#extreme-programming-xp","title":"Extreme Programming (XP)","text":""},{"location":"software-engineering/basics/agile-model/#what-is-xp","title":"What is XP?","text":"<p>XP is an agile framework focusing on technical excellence and rapid delivery through short development cycles.</p>"},{"location":"software-engineering/basics/agile-model/#core-values","title":"Core Values","text":"<pre><code>mindmap\n    root((XP Values))\n        Communication\n            Face-to-face\n            Pair Programming\n        Simplicity\n            Small Steps\n            Simple Design\n        Feedback\n            Unit Testing\n            Short Cycles\n        Courage\n            Refactoring\n            Quick Changes\n        Respect\n            Team Trust\n            Shared Code</code></pre>"},{"location":"software-engineering/basics/agile-model/#xp-lifecycle","title":"XP Lifecycle","text":"<pre><code>flowchart TD\n        A[User Stories] --&gt; B[Planning]\n        B --&gt; C[Pair Programming]\n        C --&gt; D[Unit Testing]\n        D --&gt; E[Continuous Integration]\n        E --&gt; F[Small Release]\n        F --&gt;|Next Iteration| A\n        style C fill:#f9f,stroke:#333\n        style D fill:#f9f,stroke:#333</code></pre>"},{"location":"software-engineering/basics/agile-model/#key-practices","title":"Key Practices","text":""},{"location":"software-engineering/basics/agile-model/#test-first-development","title":"Test-First Development","text":"<ul> <li>Write tests before code</li> <li>Automated testing</li> <li>Continuous validation</li> </ul>"},{"location":"software-engineering/basics/agile-model/#pair-programming","title":"Pair Programming","text":"<ul> <li>Two developers per machine</li> <li>Code review in real-time</li> <li>Knowledge sharing</li> </ul>"},{"location":"software-engineering/basics/agile-model/#continuous-integration","title":"Continuous Integration","text":"<ul> <li>Frequent code merges</li> <li>Automated builds</li> <li>Quick feedback</li> </ul>"},{"location":"software-engineering/basics/algorithms/","title":"Algorithms","text":"<p>Algorithms are step-by-step procedures or formulas for solving problems. They are essential in programming and software engineering. Here are some basic types of algorithms:</p>"},{"location":"software-engineering/basics/algorithms/#sorting-algorithms","title":"Sorting Algorithms","text":"<p>Sorting algorithms arrange the elements of a list in a specific order, usually in ascending or descending order. Common sorting algorithms include:</p> <ol> <li> <p>Bubble Sort: A simple algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. This process is repeated until the list is sorted.</p> </li> <li> <p>Selection Sort: This algorithm divides the input list into two parts: a sorted and an unsorted part. It repeatedly selects the smallest (or largest) element from the unsorted part and moves it to the sorted part.</p> </li> <li> <p>Insertion Sort: This algorithm builds the final sorted array one item at a time. It takes each element from the input and finds the appropriate position in the sorted part of the array.</p> </li> <li> <p>Merge Sort: A more efficient, recursive algorithm that divides the list into halves, sorts each half, and then merges the sorted halves back together.</p> </li> <li> <p>Quick Sort: Another efficient sorting algorithm that uses a divide-and-conquer approach. It selects a 'pivot' element and partitions the other elements into two sub-arrays according to whether they are less than or greater than the pivot.</p> </li> </ol>"},{"location":"software-engineering/basics/algorithms/#searching-algorithms","title":"Searching Algorithms","text":"<p>Searching algorithms are used to find specific data within a structure. Common searching algorithms include:</p> <ol> <li> <p>Linear Search: This algorithm checks each element in the list until the desired element is found or the list ends.</p> </li> <li> <p>Binary Search: This algorithm is more efficient than linear search but requires the list to be sorted. It repeatedly divides the search interval in half, checking if the target value is in the left or right half.</p> </li> </ol> <p>Understanding these algorithms is crucial for writing efficient code and solving complex problems in software engineering.</p>"},{"location":"software-engineering/basics/data-structures/","title":"File: /documentation-project/documentation-project/software-engineering/basics/data-structures.md","text":""},{"location":"software-engineering/basics/data-structures/#data-structures","title":"Data Structures","text":""},{"location":"software-engineering/basics/data-structures/#arrays","title":"Arrays","text":"<p>An array is a collection of items stored at contiguous memory locations. It allows you to store multiple items of the same type together. You can access elements using their index, which starts at 0.</p>"},{"location":"software-engineering/basics/data-structures/#linked-lists","title":"Linked Lists","text":"<p>A linked list is a data structure where each element (node) contains a value and a reference (link) to the next node in the sequence. Unlike arrays, linked lists do not require contiguous memory, allowing for efficient insertions and deletions.</p>"},{"location":"software-engineering/basics/data-structures/#stacks","title":"Stacks","text":"<p>A stack is a collection of elements that follows the Last In, First Out (LIFO) principle. You can add (push) and remove (pop) elements from the top of the stack only. It is commonly used for tasks like undo mechanisms in applications.</p>"},{"location":"software-engineering/basics/data-structures/#queues","title":"Queues","text":"<p>A queue is a collection of elements that follows the First In, First Out (FIFO) principle. You can add (enqueue) elements at the back and remove (dequeue) elements from the front. Queues are useful in scenarios like task scheduling.</p>"},{"location":"software-engineering/basics/design-patterns/","title":"Contents of the file: /documentation-project/documentation-project/software-engineering/basics/design-patterns.md","text":""},{"location":"software-engineering/basics/design-patterns/#design-patterns-in-software-engineering","title":"Design Patterns in Software Engineering","text":"<p>Design patterns are standard solutions to common problems in software design. They represent best practices that can be applied to various situations. Here are some of the most common design patterns:</p> <ol> <li>Singleton Pattern</li> <li>Ensures that a class has only one instance and provides a global point of access to it.</li> <li> <p>Useful when exactly one object is needed to coordinate actions across the system.</p> </li> <li> <p>Factory Pattern</p> </li> <li>Defines an interface for creating an object but allows subclasses to alter the type of objects that will be created.</li> <li> <p>Useful for managing and maintaining a large number of related classes.</p> </li> <li> <p>Observer Pattern</p> </li> <li>A one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.</li> <li> <p>Commonly used in event handling systems.</p> </li> <li> <p>Strategy Pattern</p> </li> <li>Enables selecting an algorithm's behavior at runtime.</li> <li> <p>Useful for defining a family of algorithms, encapsulating each one, and making them interchangeable.</p> </li> <li> <p>Decorator Pattern</p> </li> <li>Allows behavior to be added to individual objects, either statically or dynamically, without affecting the behavior of other objects from the same class.</li> <li> <p>Useful for adhering to the Single Responsibility Principle.</p> </li> <li> <p>Command Pattern</p> </li> <li>Encapsulates a request as an object, thereby allowing for parameterization of clients with queues, requests, and operations.</li> <li>Useful for implementing undoable operations.</li> </ol> <p>These patterns help in creating more flexible and reusable code, making it easier to manage and scale software applications.</p>"},{"location":"software-engineering/basics/sdlc-models-summary/","title":"Comparison between Various SDLC Models","text":"<p>Below is a high-level comparison of several Software Development Life Cycle (SDLC) models.</p> Aspect Waterfall Iterative Spiral Agile V-Models Incremental Development Approach Sequential Iterative Iterative Iterative Iterative Iterative Phases Linear Planning, Design, Coding, Testing, Evaluation (Repeated Iteratively) Planning, Risk Analysis, Engineering, Testing (Cyclical) Planning, Sprint, Review, Retrospective (Iterative Cycles) Planning, Design, Implementation, Testing, Deployment (Parallel) Divided into increments, each with Planning, Implementation, Testing Flexibility Low High High High Moderate High Risk Management Late Proactive Continuous Continuous Moderate Proactive Time-to-Market Longer Faster Variable Faster Moderate Faster User Involvement Limited Continuous Periodic Continuous Periodic Continuous Testing After Implementation Continuous Integrated Continuous After Implementation Continuous Adaptability Low High High High Moderate High Complexity Management Linear Adaptive Cyclical Adaptive Traceability Adaptive"},{"location":"software-engineering/basics/sdlc-models-summary/#when-to-use-which-sdlc-models","title":"When to Use Which SDLC Models?","text":"Consideration Waterfall Iterative Spiral Agile V-Models Incremental Project Size Small-Medium Medium-Large Large Small-Medium Medium-Large Small-Large Project Complexity Low-Medium Medium-High High Low-High Medium-High Medium-High Requirements Stability Stable Evolving Evolving Changing Moderate Stable-Moderate Client Involvement Limited Continuous Periodic High Periodic Continuous Budget Constraints Fixed Some Flexibility Flexible Variable Fixed Some Flexibility Risk Tolerance Low Moderate High Moderate Moderate Moderate-High Time-to-Market Moderate Faster Variable Faster Moderate Faster Documentation Emphasis Extensive Moderate Detailed Minimal Moderate Moderate Testing Approach Sequential Continuous Continuous Continuous After Phases Continuous Change Management Limited High Adaptive Highly Adaptive Moderate High"},{"location":"software-engineering/basics/sdlc-models-summary/#most-widely-used-sdlc-model","title":"Most Widely Used SDLC Model","text":"<p>Agile is the most widely used SDLC model due to its adaptability, customer satisfaction, faster time-to-market, effective risk management, collaborative environment, continuous improvement, iterative development, and sustainable pace.</p>"},{"location":"software-engineering/basics/sdlc-models/","title":"SDLC Models","text":"<p>An SDLC model is a systematic approach to the software development process that defines the stages and tasks involved in building software. It serves as a guide for planning, structuring, and controlling the process of developing information systems.</p>"},{"location":"software-engineering/basics/sdlc-models/#i-waterfall-model","title":"(i) Waterfall Model","text":"<ul> <li>The Waterfall model follows a linear and sequential approach to software development. Each phase in the development process must be completed before moving on to the next one, resembling the downward flow of a waterfall.</li> </ul> <pre><code>flowchart TD\n    A[Requirements] --&gt; B[Design]\n    B --&gt; C[Implementation/Development]\n    C --&gt; D[Verification/Testing]\n    D --&gt; E[Deployment]\n    E --&gt; F[Maintenance]</code></pre> <p>Advantages</p> <ul> <li>Easy to understand and manage</li> <li>Suitable for small projects with well-defined requirements at the beginning</li> </ul> <p>Disadvantages</p> <ul> <li>Inflexible to changes</li> <li>Testing happens late</li> <li>Limited client feedback</li> <li>No early prototypes</li> </ul>"},{"location":"software-engineering/basics/sdlc-models/#ii-iterative-model","title":"(ii) Iterative Model","text":"<p>The Iterative model develops a system through repeated cycles (iterations) and in smaller portions at a time.</p> <pre><code>flowchart TD\n    A[Initial Planning/Initialization] --&gt; B[Planning]\n    B --&gt; C[Requirements]\n    C --&gt; D[Analysis &amp; Design]\n    D --&gt; E[Implementation]\n    E --&gt; F[Testing]\n    F --&gt; G[Evaluation]\n    G --&gt;|Next Iteration| B</code></pre> <p>Advantages</p> <ul> <li>Early working version</li> <li>Flexible to changes</li> <li>Risks identified early</li> <li>Regular customer feedback</li> <li>Better risk management</li> </ul> <p>Disadvantages</p> <ul> <li>More management complexity</li> <li>Needs active customer involvement</li> <li>May extend project timeline</li> <li>Documentation challenges</li> </ul>"},{"location":"software-engineering/basics/sdlc-models/#iii-v-model-verification-and-validation-model","title":"(iii) V-Model (Verification and Validation Model)","text":"<p>The V-Model extends the waterfall model by emphasizing testing for each corresponding development stage. Each development stage has a directly associated testing phase.</p> <ul> <li>By integrating verification and validation activities in parallel, this model aims to deliver high-quality software while mitigating the risk of defects.</li> </ul> <pre><code>graph TD\n    A[Requirements] --&gt; F[Acceptance Testing]\n    B[System Design] --&gt; G[System Testing]\n    C[Architecture Design] --&gt; H[Integration Testing]\n    D[Module Design] --&gt; I[Module Testing]\n    E[Coding]\n\n    A --&gt; B\n    B --&gt; C\n    C --&gt; D\n    D --&gt; E\n    F --&gt; G\n    G --&gt; H\n    H --&gt; I\n    I --&gt; E\n\n    style A fill:#f9f,stroke:#333,stroke-width:2px\n    style F fill:#f9f,stroke:#333,stroke-width:2px\n    style E fill:#444,stroke:#444,stroke-width:2px</code></pre> <p>Advantages</p> <ul> <li>Systematic testing</li> <li>Clear deliverables</li> <li>Easy to manage</li> <li>Strong documentation</li> </ul> <p>Disadvantages</p> <ul> <li>Rigid structure</li> <li>No early prototypes</li> <li>High cost of testing</li> <li>Long development cycle</li> </ul>"},{"location":"software-engineering/basics/sdlc-models/#iv-evolutionary-models","title":"(iv) Evolutionary Models","text":"<ul> <li>Evolutionary Models are iterative.</li> </ul>"},{"location":"software-engineering/basics/sdlc-models/#1-prototyping-model","title":"1. Prototyping Model","text":"<p>A software development model where a prototype is built, tested, and refined until it meets client requirements.</p> <pre><code>flowchart TD\n    A[Initial Requirements] --&gt; B[Build Prototype]\n    B --&gt; C[Review]\n    C --&gt; D[Refine Requirements]\n    D --&gt;|Not Satisfied| B\n    D --&gt;|Satisfied| E[Development]\n    E --&gt; F[Testing]\n    F --&gt; G[Maintenance]</code></pre> <p>Best Used For</p> <ul> <li>User interface designs</li> <li>Online systems</li> <li>Web applications</li> <li>Mobile apps</li> </ul> <p>Advantages</p> <ul> <li>Early user feedback</li> <li>Clear requirements</li> <li>Reduced risk</li> <li>Better user satisfaction</li> </ul> <p>Disadvantages</p> <ul> <li>Time-consuming</li> <li>Increased cost</li> <li>Client confusion</li> <li>Incomplete documentation</li> </ul>"},{"location":"software-engineering/basics/sdlc-models/#2-spiral-model","title":"2. Spiral Model","text":"<p>The Spiral Model combines aspects of both waterfall and prototyping models, emphasizing risk analysis throughout each iteration.</p> <pre><code>flowchart LR\n    subgraph \"Iteration 1\"\n        A1[Planning] --&gt; B1[Risk Analysis]\n        B1 --&gt; C1[Engineering]\n        C1 --&gt; D1[Evaluation]\n        D1 --&gt; A2\n    end\n\n    subgraph \"Iteration 2\"\n        A2[Planning] --&gt; B2[Risk Analysis]\n        B2 --&gt; C2[Engineering]\n        C2 --&gt; D2[Evaluation]\n        D2 --&gt; A3\n    end\n\n    subgraph \"Iteration 3\"\n        A3[Planning] --&gt; B3[Risk Analysis]\n        B3 --&gt; C3[Engineering]\n        C3 --&gt; D3[Evaluation]\n    end</code></pre> <pre><code>graph TD\n    A[Planning] --&gt; B[Risk Analysis]\n    B --&gt; C[Engineering]\n    C --&gt; D[Evaluation]\n    D --&gt; A</code></pre> <ul> <li>continuous iteration of the above step....</li> </ul> <p>Four Phases per Spiral</p> <ul> <li> <p>Planning :   Objectives,   Alternatives,   Constraints,   Risk Analysis</p> </li> <li> <p>Identify risks:   Risk mitigation,   Prototyping,   Engineering</p> </li> <li> <p>Development:   Testing,   Verification,</p> </li> <li>Evaluation:   Review results,   Plan next iteration,   Decision to continue</li> </ul> <p>Best Used For:</p> <ul> <li>Large, high-risk projects</li> <li>Projects needing early user feedback</li> <li>Complex systems with unclear requirements Example: New Operating System Development</li> </ul> <p>Advantages</p> <ul> <li>High risk management</li> <li>Early prototypes</li> <li>Flexible to changes</li> <li>Regular customer feedback</li> </ul> <p>Disadvantages</p> <ul> <li>Complex management</li> <li>High documentation</li> <li>Expensive for small projects</li> <li>Needs risk assessment expertise</li> </ul>"},{"location":"software-engineering/basics/sdlc-models/#v-incremental-model","title":"(v) Incremental Model","text":"<p>Develops software in increments, with each increment adding new functionality to the previous version.</p>"},{"location":"software-engineering/basics/sdlc-models/#development-cycle","title":"Development Cycle","text":"<pre><code>flowchart TD\n        A[Requirements] --&gt;|Build 1| B1[Design]\n    subgraph \"Increment 1\"\n\n        B1 --&gt; C1[Code]\n        C1 --&gt; D1[Test]\n        D1 --&gt; E1[Release v1]\n    end\n\n    subgraph \"Increment 2\"\n        B2[Design] --&gt; C2[Code]\n        C2 --&gt; D2[Test]\n        D2 --&gt; E2[Release v2]\n    end\n\n    A --&gt;|Build 2| B2</code></pre> <p>Key Features</p> <ul> <li>Multiple Development Cycles</li> <li>Partial Systems</li> <li>Prioritized Development</li> <li>Parallel Development</li> </ul> <p>Advantages</p> <ul> <li>Early functional software</li> <li>Flexible scheduling</li> <li>Easy to test</li> <li>Risk management</li> </ul> <p>Disadvantages</p> <ul> <li>Interface challenges</li> <li>Need good planning</li> <li>System architecture issues</li> <li>Documentation overhead</li> </ul>"},{"location":"software-engineering/basics/sdlc-models/#vi-agile-model","title":"(vi) Agile Model","text":"<p>Agile is an iterative approach that focuses on collaboration, customer feedback, and rapid releases.</p>"},{"location":"software-engineering/basics/sdlc-models/#sprint-cycle","title":"Sprint Cycle","text":"<pre><code>flowchart TD\n    A[Sprint Planning] --&gt; B[Daily Standups]\n    B --&gt; C[Development]\n    C --&gt; D[Testing]\n    D --&gt; E[Sprint Review]\n    E --&gt; F[Sprint Retrospective]\n    F --&gt;|Next Sprint| A\n\n    style A fill:#f9f,stroke:#333\n    style E fill:#f9f,stroke:#333\n    style F fill:#f9f,stroke:#333</code></pre>"},{"location":"software-engineering/basics/sdlc/","title":"Software Development Life Cycle (SDLC)","text":""},{"location":"software-engineering/basics/sdlc/#what-is-sdlc","title":"What is SDLC?","text":"<p>The Software Development Life Cycle (SDLC) is a systematic process for building software applications that ensures their quality and correctness. The SDLC process aims to produce high-quality software that meets customer expectations and completes development within time and cost estimates.</p> <pre><code>graph TD\n    A[Planning] --&gt;|Requirements Gathered| B[Analysis]\n    B --&gt;|Requirements Defined| C[Design]\n    C --&gt;|Architecture Created| D[Implementation]\n    D --&gt;|Code Developed| E[Testing]\n    E --&gt;|Software Verified| F[Deployment]\n    F --&gt;|Live Release| G[Maintenance]\n    G --&gt;|Updates Required| A</code></pre>"},{"location":"software-engineering/basics/sdlc/#key-objectives","title":"Key Objectives","text":"<ul> <li>Deliver high-quality software</li> <li>Meet customer expectations</li> <li>Complete within timeline and budget</li> <li>Follow best practices and standards</li> </ul>"},{"location":"software-engineering/basics/sdlc/#sdlc-stages","title":"SDLC Stages","text":""},{"location":"software-engineering/basics/sdlc/#1-planning-and-requirement-analysis","title":"1. Planning and Requirement Analysis","text":"<pre><code>flowchart TD\n    A[Gather Requirements] --&gt; B[Analyze Requirements]\n    B --&gt; C[Document Requirements]\n    C --&gt; D[Validate Requirements]\n    D --&gt; E[Create Project Plan]</code></pre>"},{"location":"software-engineering/basics/sdlc/#2-defining-requirements","title":"2. Defining Requirements","text":"<pre><code>flowchart LR\n    A[Business Requirements] --&gt; B[Technical Requirements]\n    B --&gt; C[Functional Requirements]\n    C --&gt; D[Non-Functional Requirements]\n    D --&gt; E[SRS Document]</code></pre> <ul> <li>This is fulfilled by utilizing SRS (Software Requirement Specification). This is a sort of document that specifies all those things that need to be defined and created during the entire project cycle.</li> </ul>"},{"location":"software-engineering/basics/sdlc/#3-system-design","title":"3. System Design","text":""},{"location":"software-engineering/basics/sdlc/#two-approaches-to-system-design","title":"Two approaches to System Design:","text":"<ol> <li> <p>Top-Down Approach (High Level \u2192 Low Level)</p> </li> <li> <p>Start with overall system architecture</p> </li> <li>Break down into smaller components</li> <li> <p>Good for understanding big picture first</p> </li> <li> <p>Bottom-Up Approach (Low Level \u2192 High Level)</p> </li> <li>Start with detailed components</li> <li>Combine into larger systems</li> <li>Good for understanding implementation details first</li> </ol>"},{"location":"software-engineering/basics/sdlc/#design-hierarchy","title":"Design Hierarchy:","text":"<pre><code>graph TD\n   A[Requirements Analysis] --&gt; B[Low Level Design]\n        B --&gt; C[High Level Design]\n        C --&gt; D[System Architecture]</code></pre> <pre><code>graph TD\n    subgraph \"System Design\"\n\n        subgraph \"Low Level Design\"\n            B1[Class Design]\n            B2[Algorithm Details]\n            B3[Data Structures]\n        end\n\n        subgraph \"High Level Design\"\n            C1[Component Design]\n            C2[Interface Design]\n            C3[Database Design]\n        end\n\n        subgraph \"System Architecture\"\n            D1[Overall Structure]\n            D2[System Integration]\n            D3[Deployment Plan]\n        end\n    end</code></pre> <ul> <li>SRS is a reference for software designers to come up with the best architecture for the software. Hence, with the requirements defined in SRS, multiple designs for the product architecture are present in the Design Document Specification (DDS).</li> </ul>"},{"location":"software-engineering/basics/sdlc/#4-implementation","title":"4. Implementation","text":"<ul> <li>At this stage, the fundamental development of the product starts. For this, developers use a specific programming code as per the design in the DDS.</li> <li>Programming tools like compilers, interpreters, debuggers, etc. and languages like C/C++, Python, Java etc. are also put into use at this stage.</li> </ul> <pre><code>flowchart LR\n    A[Code Development] --&gt; B[Code Review]\n    B --&gt; C[Unit Testing]\n    C --&gt; D[Integration]</code></pre>"},{"location":"software-engineering/basics/sdlc/#5-testing-and-integration","title":"5. Testing and Integration","text":"<pre><code>flowchart TD\n    A[Unit Testing] --&gt; B[Integration Testing]\n    B --&gt; C[System Testing]\n    C --&gt; D[Acceptance Testing]\n    D --&gt; E[Performance Testing]</code></pre>"},{"location":"software-engineering/basics/sdlc/#6-deployment","title":"6. Deployment","text":"<pre><code>flowchart LR\n    A[Build Release] --&gt; B[Deploy to Staging]\n    B --&gt; C[User Acceptance]\n    C --&gt; D[Production Deployment]</code></pre>"},{"location":"software-engineering/basics/sdlc/#7-maintenance","title":"7. Maintenance","text":"<pre><code>flowchart TD\n    A[Monitor System] --&gt; B[Bug Fixes]\n    B --&gt; C[Updates]\n    C --&gt; D[Enhancements]\n    D --&gt; A</code></pre> <p>Reference: Click here</p>"},{"location":"software-engineering/basics/software-software_engineering/","title":"Software and Software Engineering","text":""},{"location":"software-engineering/basics/software-software_engineering/#software","title":"Software","text":"<p>Software is a set of programs and data that instructs a computer to perform tasks. It enables hardware to function and allows user interaction.</p>"},{"location":"software-engineering/basics/software-software_engineering/#types-of-software","title":"Types of Software","text":"<ul> <li>System Software: Manages hardware and provides a platform for other software (e.g., operating systems like Windows, macOS, Linux).</li> <li>Application Software: Designed for end-users to perform specific tasks (e.g., web browsers, media players, office suites).</li> <li>Programming Software: Provides tools for developers to write, test, and debug code (e.g., compilers, text editors, IDEs).</li> <li>Middleware: Acts as a bridge between different applications and system software.</li> </ul>"},{"location":"software-engineering/basics/software-software_engineering/#software-engineering","title":"Software Engineering","text":"<p>Software Engineering involves designing, developing, testing, and maintaining software systematically to ensure quality and reliability.</p>"},{"location":"software-engineering/basics/software-software_engineering/#key-principles","title":"Key Principles","text":"<ul> <li>Modularity: Break software into smaller parts.</li> <li>Abstraction: Hide implementation details.</li> <li>Encapsulation: Protect internal state.</li> <li>Reusability: Use components in multiple projects.</li> <li>Maintenance: Regular updates and improvements.</li> <li>Testing: Ensure software meets requirements.</li> <li>Design Patterns: Templates for solving design problems.</li> <li>Agile Methodologies: Iterative development focused on customer satisfaction.</li> <li>Continuous Integration &amp; Deployment: Regularly integrate and deploy code.</li> </ul>"},{"location":"software-engineering/basics/software-software_engineering/#main-attributes","title":"Main Attributes","text":"<ul> <li>Efficiency: Resource usage.</li> <li>Reliability: Consistent performance.</li> <li>Reusability: Use in multiple applications.</li> <li>Maintainability: Easy to modify and enhance.</li> </ul>"},{"location":"software-engineering/basics/software-software_engineering/#dual-role-of-software","title":"Dual Role of Software","text":"<ol> <li>As a Product: Enables hardware functionality and information processing.</li> <li>As a Vehicle for Delivering a Product: Provides system functionality and helps build other software.</li> </ol>"},{"location":"software-engineering/basics/software-software_engineering/#objectives","title":"Objectives","text":"<ul> <li>Maintainability: Adapt to changes.</li> <li>Efficiency: Optimal resource use.</li> <li>Correctness: Meets requirements.</li> <li>Reusability: Easy module reuse.</li> <li>Testability: Facilitate testing.</li> <li>Reliability: Consistent function.</li> <li>Portability: Transferable across systems.</li> <li>Adaptability: Satisfy varying needs.</li> <li>Interoperability: Cooperative data processing.</li> </ul>"},{"location":"software-engineering/basics/software-software_engineering/#program-vs-software-product","title":"Program vs Software Product","text":"Parameters Program Software Product Definition Instructions for a task. Commercially available, documented, licensed. Stages Involved Single stage. Full life cycle: feasibility, requirements, design, coding, testing. <ul> <li> <p>A program is a set of instructions that are given to a computer in order to achieve a specific task.</p> </li> <li> <p>Software is when a program is made available for commercial business and is properly documented along with its licensing.</p> </li> </ul>"},{"location":"software-engineering/basics/software-software_engineering/#advantages","title":"Advantages","text":"<ul> <li>Improved Quality: Fewer bugs.</li> <li>Increased Productivity: Streamlined process.</li> <li>Better Maintainability: Easier updates.</li> <li>Reduced Costs: Early problem detection.</li> <li>Increased Customer Satisfaction: Meets needs.</li> <li>Better Team Collaboration: Agile methods.</li> <li>Better Scalability: Designed for growth.</li> <li>Better Security: Prevents breaches.</li> </ul>"},{"location":"software-engineering/basics/software-software_engineering/#disadvantages","title":"Disadvantages","text":"<ul> <li>High Upfront Costs: Investment needed.</li> <li>Limited Flexibility: Slow adaptation.</li> <li>Bureaucratic: Slows development.</li> <li>Complexity: Hard to navigate.</li> <li>Limited Creativity: Structured approach.</li> <li>High Learning Curve: Extensive training.</li> <li>Tool Dependence: Issues with tools.</li> <li>High Maintenance: Costly upkeep.</li> </ul> <p>In summary, software engineering provides a structured approach to develop high-quality, maintainable software, improving customer satisfaction and reducing costs.</p> <p>Reference : Click here</p>"},{"location":"virtual-environment/information/virtual-env-info/","title":"Virtual Environments","text":"<p>Virtual environments are isolated environments that allow you to manage dependencies for different projects separately. They are particularly useful in Python development, where different projects may require different versions of libraries.</p>"},{"location":"virtual-environment/information/virtual-env-info/#purpose-of-virtual-environments","title":"Purpose of Virtual Environments","text":"<ol> <li>Dependency Management: Virtual environments help manage project-specific dependencies without affecting the global Python installation.</li> <li>Version Control: You can maintain different versions of libraries for different projects, ensuring compatibility and stability.</li> <li>Isolation: Each virtual environment is self-contained, preventing conflicts between packages used in different projects.</li> </ol>"},{"location":"virtual-environment/information/virtual-env-info/#common-tools-for-creating-virtual-environments","title":"Common Tools for Creating Virtual Environments","text":"<ul> <li>venv: A built-in module in Python 3 that allows you to create lightweight virtual environments.</li> <li>virtualenv: A third-party tool that provides more features and supports older versions of Python.</li> <li>conda: A package manager that can create virtual environments and manage packages for Python and other languages.</li> </ul>"},{"location":"virtual-environment/information/virtual-env-info/#basic-commands","title":"Basic Commands","text":""},{"location":"virtual-environment/information/virtual-env-info/#using-venv","title":"Using <code>venv</code>","text":"<ol> <li> <p>Create a Virtual Environment:    <pre><code>python -m venv myenv\n</code></pre></p> </li> <li> <p>Activate the Virtual Environment:</p> </li> <li>On Windows:      <pre><code>myenv\\Scripts\\activate\n</code></pre></li> <li> <p>On macOS/Linux:      <pre><code>source myenv/bin/activate\n</code></pre></p> </li> <li> <p>Deactivate the Virtual Environment:    <pre><code>deactivate\n</code></pre></p> </li> </ol>"},{"location":"virtual-environment/information/virtual-env-info/#using-virtualenv","title":"Using <code>virtualenv</code>","text":"<ol> <li> <p>Install virtualenv (if not already installed):    <pre><code>pip install virtualenv\n</code></pre></p> </li> <li> <p>Create a Virtual Environment:    <pre><code>virtualenv myenv\n</code></pre></p> </li> <li> <p>Activate and Deactivate: Same as above.</p> </li> </ol>"},{"location":"virtual-environment/information/virtual-env-info/#using-conda","title":"Using <code>conda</code>","text":"<ol> <li> <p>Create a Virtual Environment:    <pre><code>conda create --name myenv\n</code></pre></p> </li> <li> <p>Activate the Virtual Environment:    <pre><code>conda activate myenv\n</code></pre></p> </li> <li> <p>Deactivate the Virtual Environment:    <pre><code>conda deactivate\n</code></pre></p> </li> </ol>"},{"location":"virtual-environment/information/virtual-env-info/#conclusion","title":"Conclusion","text":"<p>Using virtual environments is a best practice in software development, especially for Python projects. They help maintain clean and manageable project dependencies, making it easier to work on multiple projects simultaneously.</p>"},{"location":"virtual-environment/snippets/create-virtual-env/","title":"Creating a Virtual Environment","text":""},{"location":"virtual-environment/snippets/create-virtual-env/#python","title":"Python","text":"<p>To create a virtual environment in Python, follow these steps:</p> <ol> <li> <p>Install <code>virtualenv</code> (if not already installed): <code>pip install virtualenv</code></p> </li> <li> <p>Navigate to your project directory: <code>cd your-project-directory</code></p> </li> <li> <p>Create a virtual environment: <code>virtualenv venv</code></p> </li> <li> <p>Activate the virtual environment:</p> </li> <li> <p>On Windows:      <pre><code>venv\\Scripts\\activate\n</code></pre></p> </li> <li> <p>On macOS/Linux:      <pre><code>source venv/bin/activate\n</code></pre></p> </li> <li> <p>Deactivate the virtual environment when done:    <pre><code>deactivate\n</code></pre></p> </li> </ol>"},{"location":"virtual-environment/snippets/create-virtual-env/#nodejs","title":"Node.js","text":"<p>To create a virtual environment in Node.js, you can use <code>nvm</code> (Node Version Manager):</p> <ol> <li> <p>Install <code>nvm</code> (if not already installed):    Follow the installation instructions from the nvm repository.</p> </li> <li> <p>Install a specific Node.js version: <code>nvm install &lt;version&gt;</code></p> </li> <li> <p>Use the installed version: <code>nvm use &lt;version&gt;</code></p> </li> <li> <p>Deactivate the version: <code>nvm deactivate</code></p> </li> </ol>"}]}